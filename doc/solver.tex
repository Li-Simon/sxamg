\chapter{AMG Solver}

\section{Data Structures}

\nverb{SX_SM_TYPE} defines smoother types. Nine smoothers are implemented.
\begin{evb}
typedef enum
{
    SX_SM_JACOBI    = 1,  /**< Jacobi smoother */
    SX_SM_GS        = 2,  /**< Gauss-Seidel smoother */
    SX_SM_SGS       = 3,  /**< Symmetric Gauss-Seidel smoother */
    SX_SM_SOR       = 4,  /**< SOR smoother */
    SX_SM_SSOR      = 5,  /**< SSOR smoother */
    SX_SM_GSOR      = 6,  /**< GS + SOR smoother */
    SX_SM_SGSOR     = 7,  /**< SGS + SSOR smoother */
    SX_SM_POLY      = 8,  /**< Polynomial smoother */
    SX_SM_L1DIAG    = 9,  /**< L1 norm diagonal scaling smoother */

} SX_SM_TYPE;
\end{evb}

\nverb{SX_COARSEN_TYPE} defines coarsening types, including classical RS coarsening and
classical RS coarsening with positive off-diagonals.
\begin{evb}
typedef enum
{
    SX_COARSE_RS      = 1,  /**< Classical */
    SX_COARSE_RSP     = 2,  /**< Classical, with positive offdiags */

} SX_COARSEN_TYPE;
\end{evb}


\nverb{SX_INTERP_TYPE} defines interpolation types, including direct interpolation
and standard interpolation.
\begin{evb}
typedef enum
{
    SX_INTERP_DIR     = 1,  /**< Direct interpolation */
    SX_INTERP_STD     = 2,  /**< Standard interpolation */

} SX_INTERP_TYPE;
\end{evb}


\nverb{SX_AMG_PARS} defines AMG parameters. The meaning of each member is explained as comment. For example,
\nverb{cycle_itr}
determines the cycle type: 1 for V-cycle, 2 for W-cycle..
\begin{evb}
typedef struct SX_AMG_PARS
{
    SX_INT verb;

    SX_INT   cycle_itr;          /** type of AMG cycle, 1 is for V, 2 for W */
    SX_FLOAT tol;                /** stopping tolerance for AMG solver */
    SX_FLOAT ctol;               /** stopping tolerance for coarsest solver */
    SX_INT   maxit;              /** maximal number of iterations of AMG */

    SX_COARSEN_TYPE cs_type;     /** coarsening type */
    SX_INT max_levels;           /** max number of levels of AMG */
    SX_INT coarse_dof;           /** max number of coarsest level DOF */

    SX_SM_TYPE smoother;         /** smoother type */
    SX_FLOAT relax;              /** relax parseter for SOR smoother */
    SX_INT cf_order;             /** False (0): nature order, True (1): C/F order */
    SX_INT pre_iter;             /** number of presmoothers */
    SX_INT post_iter;            /** number of postsmoothers */
    SX_INT poly_deg;             /** degree of the polynomial smoother */

    SX_INTERP_TYPE interp_type;  /** interpolation type */
    SX_FLOAT strong_threshold;   /** strong connection threshold for coarsening */
    SX_FLOAT max_row_sum;        /** maximal row sum parseter */
    SX_FLOAT trunc_threshold;    /** truncation threshold */

} SX_AMG_PARS;
\end{evb}

\nverb{SX_RTN} is for return values.
\begin{evb}
typedef struct SX_RTN
{
    SX_FLOAT ares;     /* absolute residual */
    SX_FLOAT rres;     /* relative residual */
    SX_INT   nits;     /* number of iterations */

} SX_RTN;
\end{evb}

\section{Management}

\subsection{Initialize Parameters}

\nverb{sx_amg_pars_init} sets default parameters.
\begin{evb}
void sx_amg_pars_init(SX_AMG_PARS *pars);
\end{evb}

\subsection{Setup}
\nverb{sx_amg_setup} setups the hierarchical struture of AMG solver,
\begin{evb}
SX_AMG * sx_amg_setup(SX_MAT *A, SX_AMG_PARS *pars);
\end{evb}

\subsection{Solve}

\nverb{sx_solver_amg_solve} solves the linear system using AMG method,
\begin{evb}
SX_RTN sx_solver_amg_solve(SX_AMG *mg, SX_VEC *x, SX_VEC *b);
\end{evb}

\nverb{sx_solver_amg} solves the linear system using AMG method. This function is a high level 
interface, and user can call it only to solve a linear system, which will setup the AMG solver,
solve and destroy the AMG solver.
\begin{evb}
SX_RTN sx_solver_amg(SX_MAT *A, SX_VEC *x, SX_VEC *b, SX_AMG_PARS *pars);
\end{evb}

\subsection{Destroy}
\nverb{sx_amg_data_destroy} destroys the AMG object,
\begin{evb}
void sx_amg_data_destroy(SX_AMG **mg);
\end{evb}

